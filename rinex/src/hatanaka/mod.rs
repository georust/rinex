//! RINEX compression / decompression module
use thiserror::Error;

// TODO
// Improve Result<> IoError/Error relation ship
// the current User API .read().error()
// Will trigger a string comparison on every single .read() acces veritication

mod compressor;
mod crinex;
mod decompressor;
mod numdiff;
mod obs;
mod textdiff;

pub use compressor::Compressor;
pub use crinex::CRINEX;

pub use decompressor::{Decompressor, DecompressorExpert};

pub(crate) use numdiff::NumDiff;
pub(crate) use obs::ObsDiff;
pub(crate) use textdiff::TextDiff;

use std::io::{Error as IoError, ErrorKind};

/// Hatanaka dedicated Errors
#[derive(Debug)]
pub enum Error {
    /// Invalid UTF-8 content
    BadUtf8Data,
    /// Buffer too small to accept incoming data
    BufferOverflow,
    /// Failed to read CRINEX PROG/DATE
    CrinexParsing,
    /// Forwarded Epoch description does not look good: Invalid RINEX!
    EpochFormat,
    /// Recovered Epoch descriptor (in the decompression scheme)
    /// does not look good. Most likely due to invalid content
    /// generated by the decompressor: should never happen
    RecoveredEpochFormat,
    /// Recovered or forwarded SV description is incorrect (bad data)
    SVFormat,
    /// [SV] identification error: bad relationship between
    /// either:
    ///   - recovered Epoch description (in decompression scheme)
    ///   and parsing process
    ///   - invalid data being forwared and/or incompatibility
    ///   with previously formwared Header
    SVParsing,
    /// It is mandatory that the CRINEX version be correctly defined
    /// so we can parse it and adapt the (de-)compression scheme
    VersionParsing,
    /// Keep reading: need more data to progress (FSM stuck)
    NeedMoreData,
}

impl Error {
    // /// Converts [IoError] to [Self] when possible
    // pub fn from_stdio(&self, error: IoError) -> Option<Self> {
    //     match error.kind() {
    //         ErrorKind::Other => Some(Self::HeaderUtf8Data),
    //         // ErrorKind::Other("bad utf-8 in header") => Some(Self::HeaderUtf8Data),
    //         // IoError::Other("invalid epoch description") => Some(Self::EpochFormat),
    //         // IoError::Other("invalid recovered epoch") => Some(Self::RecoveredEpochFormat),
    //         // IoError::Other("invalid sv formatting") => Some(Self::SVFormat),
    //         // IoError::Other("sv parsing") => Some(Self::SVParsing),
    //         // IoError::Other("crinex version parsing") => Some(Self::VersionParsing),
    //         _ => None,
    //     }
    // }
    /// Converts [Error] to custom [IoError]
    fn to_stdio(&self) -> IoError {
        let descriptor = match self {
            Self::BadUtf8Data => "bad utf-8 data",
            Self::BufferOverflow => "read buf overflow",
            Self::EpochFormat => "invalid epoch description",
            Self::RecoveredEpochFormat => "invalid recovered epoch",
            Self::SVFormat => "invalid sv formatting",
            Self::SVParsing => "sv parsing",
            Self::VersionParsing => "crinex version parsing",
            Self::CrinexParsing => "crinex specs parsing",
            Self::NeedMoreData => "need more data",
        };
        IoError::new(ErrorKind::Other, descriptor)
    }
}
